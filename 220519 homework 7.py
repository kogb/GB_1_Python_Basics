# 1. Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора
# класса (метод __init__()), который должен принимать данные 
# ( список списков) для формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, 
# расположенных в виде прямоугольной схемы.
# Примеры матриц: 3 на 2, 3 на 3, 2 на 4.
# 
# 31    32         3    5    32        3    5    8    3
# 37    43         2    4    6         8    3    7    1
# 51    86        -1   64   -8
# Следующий шаг — реализовать перегрузку метода __str__() для вывода 
# матрицы в привычном виде.
# Далее реализовать перегрузку метода __add__() для реализации операции 
# сложения двух объектов класса Matrix (двух матриц). 
# Результатом сложения должна быть новая матрица.
# одсказка: сложение элементов матриц выполнять поэлементно — 
# первый элемент первой строки первой матрицы складываем 
# с первым элементом первой строки второй матрицы и т.д.

from itertools import zip_longest

class Matrix:
    def __init__(self, list_vol):
        self.list_vol = list_vol
        
    def __add__(self, oser):
        '''
        Можно работать с листами любой длины и любой вложенности
        '''
        new_list_vol = [[] for _ in range(max(len(self.list_vol), len(oser.list_vol)))] 
        for y, y2 in zip_longest(range(len(self.list_vol)), range(len(oser.list_vol))):
            if y == None:
                for x2 in range(len(oser.list_vol[y2])): 
                    new_list_vol[y2].append(oser.list_vol[y2][x2])
            elif y2 == None:
                for x in range(len(self.list_vol[y])): 
                    new_list_vol[y].append(self.list_vol[y][x])        
            else:                
                for x, x2 in zip_longest(range(len(self.list_vol[y])), range(len(oser.list_vol[y2]))):
                    if x == None:
                        new_list_vol[y2].append(oser.list_vol[y2][x2])
                    elif x2 == None:   
                        new_list_vol[y].append(self.list_vol[y][x])
                    else:    
                        new_list_vol[y].append(self.list_vol[y][x]+oser.list_vol[y2][x2])  
        return Matrix(new_list_vol)
        
         
    def __str__(self):
        vol_print = ""
        for y in self.list_vol:
            y = [str(i) for i in y]
            y_str = " ".join(y)
            vol_print += y_str + '\n'
        return vol_print                               

list_vol_a = [[51,86,9,8],[37,43,48],[51,86,9],[37,43,48],[37,43,48]]
a = Matrix(list_vol_a)

list_vol_b = [[1,2,4],[3,4,7,3,4,3],[0,8,4],[0,8,8,4]]
b = Matrix(list_vol_b)
print(a+b)

#######################################################################
# 2. Реализовать проект расчёта суммарного расхода ткани на 
# производство одежды. 
# Основная сущность (класс) этого проекта — одежда, которая 
# может иметь определённое название. К типам одежды в этом проекте 
# относятся пальто и костюм. У этих типов одежды существуют параметры: 
# размер (для пальто) и рост (для костюма). 
# Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать 
# формулы: для пальто (V/6.5 + 0.5), для костюма (2*H + 0.3). 
# Проверить работу этих методов на реальных данных.
# Реализовать общий подсчет расхода ткани. Проверить на практике 
# полученные на этом уроке знания: реализовать абстрактные классы для 
# основных классов проекта, проверить на практике работу декоратора 
# @property.
class Circle:
    
    def __init__(self, r):
        self.r = r
    @
    def area(self):
        return 3.1415 * self.r**2
c = Circle(10)
print(c.area)

class Clothes:
    count = 0
    amount_of_fabric_vol = [[],[]]
    def __init__(self, size, height):
        self.size = size
        self.height = height
        Clothes.count += 1
    
    
    def amount_of_fabric(self, oser):
        return
        
class Coat(Clothes):
    def __init__(self, size):
        self.size = size  
        
    def fab_calc(self):
        return self.size/6.5 + 0.5
    
    
class Suit(Clothes):
    def __init__(self, height):
        self.height = height 
    
    def fab_calc(self):
        return 2*self.height + 0.3
    

        


Elema = Coat(5)
print(Elema.fab_calc())
Comintern = Suit(5)
print(Comintern.fab_calc())


class MyClass:
    def __init__(self, param_1, param_2):
        self.param_1 = param_1
        self.param_2 = param_2
    @property
    def my_method(self):
        return f"Параметры, переданные в класс:" \
            f" {self.param_1}, {self.param_2}"
mc = MyClass("text_1", "text_2")
print(mc.param_1)
print(mc.param_2)
print(mc.my_method)

class Auto:

    # конструктор класса Auto
    def __init__(self, year):
        # Инициализация свойств.
        self.year = year

    # создаем свойство года
    @property
    def year(self):
        return self.__year

    # сеттер для создания свойств
    @year.setter
    def year(self, year):
        if year < 2000:
            self.__year = 2000
        elif year > 2019:
            self.__year = 2019
        else:
            self.__year = year

    def get_auto_year(self):
        return f"Автомобиль выпущен в {str(self.year)} году"

a = Auto(2090)
print(a.get_auto_year())
# Свойство обладает тремя важными аспектами. 
# Первым делом необходимо определить атрибут — год выпуска автомобиля. 
# Далее необходимо определить свойство атрибута с помощью декоратора @property. 
# Третий шаг — создать установщик свойства (сеттер), применив декоратор для параметра года: @year.setter.

a = Auto(1990)
print(a.get_auto_year())


a = Auto(2990)
print(a.get_auto_year())







# 3. Реализовать программу работы с органическими клетками, 
# состоящими из ячеек. Необходимо создать класс Клетка. 
# В его конструкторе инициализировать параметр, соответствующий 
# количеству ячеек клетки (целое число). В классе должны быть 
# реализованы методы перегрузки арифметических операторов: сложение 
# (__add__()), вычитание (__sub__()), умножение (__mul__()), 
# деление (__truediv__()). Данные методы должны применяться только 
# к клеткам и выполнять увеличение, уменьшение, умножение 
# и целочисленное (с округлением до целого) деление клеток, 
# соответственно.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки 
# должно равняться сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять 
# только если разность количества ячеек двух клеток больше нуля, 
# иначе выводить соответствующее сообщение.
# Умножение. Создаётся общая клетка из двух. Число ячеек общей 
# клетки определяется как произведение количества ячеек этих двух клеток.
# Деление. Создаётся общая клетка из двух. Число ячеек общей клетки 
# определяется как целочисленное деление количества ячеек этих двух 
# клеток.

# В классе необходимо реализовать метод make_order(), принимающий 
# экземпляр класса и количество ячеек в ряду. Данный метод позволяет 
# организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., 
# где количество ячеек между \n равно переданному аргументу. 
# Если ячеек на формирование ряда не хватает, то в последний ряд 
# записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек 
# в ряду — 5. Тогда метод make_order() вернёт строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. 
# Тогда метод make_order() вернёт строку: *****\n*****\n*****.
# Подсказка: подробный список операторов для перегрузки доступен по 
# ссылке.

